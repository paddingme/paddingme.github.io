--- 
wordpress_id: 30
title: Out of the Box Grails + JEE Integration
wordpress_url: http://jasonrudolph.com/blog/2006/12/18/out-of-the-box-grails-jee-integration/
layout: post
tags:
- grails
- gswg
- java	
---
There&#39;s something to be said for things that <a href="http://movies.apple.com/movies/us/apple/getamac_ads2/box_480x376.mov" title="Get a Mac">just work</a> right out of the box, and JEE integration with Grails falls nicely into that category.&nbsp; When people first hear about Grails and they see demonstrations of its rapid application development (RAD) capabilities, it&rsquo;s not long before an air of skepticism seems to set in.&nbsp; Surely a framework offering this level of productivity can&rsquo;t possibly play nicely with a corporation&rsquo;s highly-configurable and often complex application servers.&nbsp; Of course, this isn&rsquo;t a new topic, as we&#39;ve certainly explored some of <a href="http://jasonrudolph.com/blog/2006/06/20/hoisting-grails-to-your-legacy-db/">these</a> <a href="http://www.infoq.com/articles/grails-ejb-tutorial">areas</a> before.&nbsp; Nevertheless, questions remain, and any new technology has to prove its worth. &nbsp;<br /> <br /> One rather common question concerns the ability to hook into an app server&rsquo;s data sources using JNDI.&nbsp; If you&#39;ve invested in a JEE container, there&#39;s a good chance you want to make use of its database connection pooling.&nbsp; (For that matter, it&#39;s probably a company policy to do so.)&nbsp; And, needless to say, beyond just connection pooling, using data sources also offers the added security and maintenance benefits of not packaging your database user ID, password, and URL inside your application.<br /> <br /> So, what does it take to get a Grails app to obtain its database connections from a container-managed data source?&nbsp; Assuming you have your data source configured in your app server, it&rsquo;s as simple as telling Grails how to look it up.&nbsp; Let&rsquo;s first take a look at the data source definition in the app server.&nbsp; For this example, we&rsquo;ll look at a MySQL data source configured in JBoss Application Server.<br /> <br /> <pre><font face="Courier">$ <strong>cat /Applications/jboss-4.0.5.GA/server/default/deploy/mysql-ds.xml</strong><br /> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br /> &lt;datasources&gt;<br /> &nbsp;&nbsp;&nbsp; &lt;local-tx-datasource&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;jndi-name&gt;</font><font face="Courier" color="#0000ff">jdbc/racetrack</font><font face="Courier">&lt;/jndi-name&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;connection-url&gt;jdbc:mysql://localhost/racetrack_prod&lt;/connection-url&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;user-name&gt;prod&lt;/user-name&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;wahoowa&lt;/password&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter&lt;/exception-sorter-class-name&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;metadata&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;type-mapping&gt;mySQL&lt;/type-mapping&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/metadata&gt;<br /> &nbsp;&nbsp;&nbsp; &lt;/local-tx-datasource&gt;<br /> &lt;/datasources&gt;</font></pre><br /> Once we know the JNDI name for the data source &ndash; in this case, we see from the output above that it&rsquo;s <font face="Courier">jdbc/racetrack</font> &ndash; we simply <a href="http://www.grails.org/Configuration#Configuration-JNDI">define a Spring bean for that data source</a> in <font face="Courier">$PROJECT_HOME/spring/resources.xml</font> (where <font face="Courier">$PROJECT_HOME</font> is the root directory of your Grails application).<br /> <br /> <pre><font face="Courier">$ <strong>cat racetrack/spring/resources.xml</strong><br /> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br /> &lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&gt;<br /> &lt;beans&gt;<br /> &nbsp;&nbsp;&nbsp; &lt;bean id=&quot;dataSource&quot;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;<br /> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;property name=&quot;jndiName&quot; value=&quot;</font><font face="Courier" color="#0000ff">java:jdbc/racetrack</font><font face="Courier">&quot;/&gt;<br /> &nbsp;&nbsp;&nbsp; &lt;/bean&gt;<br /> &lt;/beans&gt;<br /> <br /> </font></pre> <p>Then, just run <font face="Courier">grails war</font> to create the WAR, and that&rsquo;s it.&nbsp; Now, when you deploy the WAR to your app server, your Grails application will use your container-managed data source for all of its database access.<br /> <br /> So, what other types of JEE integration would you look for in your Grails apps?&nbsp; (Sound off in the comments, and perhaps we&rsquo;ll have additional posts on this topic.)&nbsp; If you found this particular example to be a bit trivial, great!&nbsp; That&rsquo;s exactly the point.&nbsp; JEE integration doesn&rsquo;t have to be painful, at least not with Grails. &nbsp;</p> <h3>Resources&nbsp;</h3> <ul> 	<li>JBoss configuration file for MySQL data source - <a href="/resources/20061218/mysql-ds.xml">mysql-ds.xml</a></li> 	<li>Spring configuration file - <a href="/resources/20061218/resources.xml">resources.xml</a></li> 	<li>The rest of this mysterious <em>racetrack</em> sample application - Coming soon!</li> </ul><br />
